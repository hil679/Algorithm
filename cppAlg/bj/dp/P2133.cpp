#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;
    int dp[31] = {};

    dp[2] = 2*2 - 1;
    /*
    앞 뒤 2열씩 잘랐을 때
    같은 전체 타일링인데,
    어떤 때는 “앞=이 모양(P1), 뒤=저 타일링(T1)”로 볼 수도 있고
    또 어떤 때는 “앞=다른 모양(P2), 뒤=다른 타일링(T2)”로도 볼 수 있는 경우
    즉 “같은 완성 배치”를 두 가지 방식으로 잘라서 설명할 수 있을 때 중복

    (A) 왼쪽 2칸에서 완전히 닫히는가? → 3가지 케이스
    아니라면
    (B) 왼쪽에서 시작한 특수 모양이 “처음으로” 닫히는 위치가 어디인가? → 4, 6, 8, …

    dp[4] = dp[2] * dp[2] + 2;
    dp[6] = dp[4] * dp[2] + 2(dp[4]의 유일 개수)*dp[2] + 2
    dp[8] = dp[6] * dp[2](dp[6]에 dp[2]를 뒤에 붙임)
    +dp[2]*2(dp[6]의 유일 개수) => dp[2]로 이루어진 dp[6]은 앞에 dp[2] 붙인 것과 뒤에 dp[2] 붙인 것과 겹침
    + 2(dp[4]의 유일 개수) * dp[4]
    + 2(dp[8]의 유일 개수);
    dp[10] = dp[8] * dp[2] +2*dp[8]+ dp[6] * 2 + dp[4] * 2
    */
    for (int i = 4; i <= n; i+=2) {
        dp[i] = dp[i-2] * dp[2] + 2;
        for (int j = i - 4; j >= 2; j -= 2) {
            dp[i] += dp[j] * 2;
        }
    }
    cout << dp[n];
}